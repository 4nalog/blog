---
title: Folding the DOM
slug: folding-the-dom
published: false
publishedOn: 2018-10-05
abstract: A deep dive into DOM folding techniques, to be used in animations and interactions.
---

import { Spring } from 'react-spring';
import { State } from 'react-powerplug';

import cssEngineSrc from '@assets/videos/css-engine.mp4';
import autumnSrc from '@assets/images/sandis-helvigs-autumn.jpg';
import pigletSrc from '@assets/images/annie-spratt-piglet.jpg';

import Demo from '@components/Demo';
import MultipleChoiceControl, {
  Choice,
} from '@components/MultipleChoiceControl';
import SliderControl from '@components/SliderControl';
import TextLink from '@components/TextLink';
import SingleAxisDemo from '@components/SingleAxisDemo';
import VideoGif from '@components/VideoGif';
import InlineCode from '@components/InlineCode';
import AutoRotate from '@components/AutoRotate';
import { SingleFoldByRatio } from '@components/FoldDemos';

In my day-to-day life as a web developer, I generally treat CSS as a collection of 2D layers. Other than reordering them using z-index, I don't often _move_ things in 3D space.

And yet, for _years_ now, browsers have bundled in a surprisingly capable 3D CSS engine! Someone even built an experimental first-person shooter prototype using it ðŸ˜®

<VideoGif
  src={cssEngineSrc}
  caption={
    <>
      Believe it or not, this is just a collection of textured divs!{' '}
      <TextLink href="https://keithclark.co.uk/labs/css-fps/">
        View Live
      </TextLink>
    </>
  }
/>

Today I'd like to leverage that 3D engine to perform a neat trick: folding up a DOM node. This effect is a great way to add some whimsical charm to your web products.

Take a look at what I mean, by unfolding this [beautiful autumn photo](https://unsplash.com/photos/vrY49w_-Bmc) by Sandis Helvigs:

<SingleAxisDemo showNote={true} defaultValue={100} id="fold-intro">
  {percentage => (
    <Spring
      to={{ percentage }}
      config={{
        tension: 60,
        friction: 13,
      }}
    >
      {interpolated => (
        <SingleFoldByRatio
          // The height of our node should be a fraction of the window height,
          // but no larger than 500px
          height={
            typeof window !== 'undefined' &&
            Math.min(Math.round(window.innerHeight * 0.6), 500)
          }
          // Our width is just 2/3rds of our height.
          // Regrettably, because MDX doesn't support variables, I have to
          // duplicate all that stuff:
          width={
            typeof window !== 'undefined' &&
            Math.min(Math.round(window.innerHeight * 0.6 * 0.666), 333)
          }
          percentage={interpolated.percentage}
        >
          <img src={autumnSrc} style={{ height: 500 }} />
        </SingleFoldByRatio>
      )}
    </Spring>
  )}
</SingleAxisDemo>

## The Trick

Unfortunately, the DOM has no primitive for this; you can't actually fold a DOM node in two.

Instead, we need to be sneaky; we'll use _two_ images, and set them up so that it appears like a single image.

If we only needed to support images, we could use `background-position` to "crop" the second image, exactly as we need:

<Demo
  id="transform-rotate"
  initialValues={{
    offset: 0,
  }}
  controls={(values, updateValue) => (
    <>
      <SliderControl
        id="offset"
        label="Offset"
        min={0}
        max={250}
        value={values.offset}
        updateValue={updateValue}
      />
    </>
  )}
>
  {({ offset }) => (
    <Spring
      to={{ offset }}
      config={{
        tension: 60,
        friction: 13,
      }}
    >
      {interpolated => {
        return (
          <div
            style={{
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
            }}
          >
            <div
              style={{
                width: 333,
                height: 250,
                backgroundSize: '333px 500px',
                backgroundImage: `url(${autumnSrc})`,
                borderRadius: offset < 250 ? '0 0 0 0' : '10px 10px 0 0',
              }}
            />
            <div
              style={{
                width: 333,
                height: 250,
                backgroundSize: '333px 500px',
                backgroundImage: `url(${autumnSrc})`,
                backgroundPosition: `0px -${interpolated.offset}px`,
                borderRadius: offset < 250 ? '0 0 0 0' : '0 0 10px 10px',
                transform: `translateY(${offset < 250 ? 5 : 0}px)`,
                transition: 'transform 250ms',
              }}
            />
            <InlineCode
              style={{
                position: 'relative',
                zIndex: 2,
                fontSize: 24,
                marginTop: 30,
              }}
            >
              background-position: '0px -{Math.round(interpolated.offset)}px'
            </InlineCode>
          </div>
        );
      }}
    </Spring>
  )}
</Demo>

Pretty convincing, right? By juxtaposing the same image twice, and tweaking the offset of the background image, we're able to give the impression of a single
image.

To achieve a realistic folding effect, we'll need to leverage a few CSS properties.

## Transform

Transform is our gateway to all sorts of effects. With transform, we can move stuff around, scale it larger and smaller, skew it, or rotate it.

In our case, we want to use a rotation, along the X axis:

<Demo
  id="transform-rotate"
  initialValues={{
    axis: 'X',
    degrees: 0,
  }}
  controls={(values, updateValue) => (
    <>
      <MultipleChoiceControl
        id="axis"
        label="Axis"
        value={values.axis}
        updateValue={updateValue}
      >
        <Choice id="X">X Axis</Choice>
        <Choice id="Y">Y Axis</Choice>
        <Choice id="Z">Z Axis</Choice>
      </MultipleChoiceControl>
      <SliderControl
        id="degrees"
        label="Degrees"
        min={0}
        max={360}
        value={values.degrees}
        updateValue={updateValue}
      />
    </>
  )}
>
  {({ axis, degrees }) => (
    <Spring
      to={{ degrees }}
      config={{
        tension: 60,
        friction: 13,
      }}
    >
      {interpolated => {
        const transform = `rotate${axis}(${interpolated.degrees}deg)`;
        //
        return (
          <div>
            <div
              style={{
                paddingBottom: 30,
              }}
            >
              <InlineCode
                style={{
                  position: 'relative',
                  zIndex: 2,
                  width: 400,
                  fontSize: 24,
                }}
              >
                transform: rotate{axis}({Math.round(interpolated.degrees)}deg)
              </InlineCode>
            </div>
            <img
              width={400}
              height={321}
              src={pigletSrc}
              style={{ transform }}
            />
            <div
              style={{
                position: 'relative',
                zIndex: 2,
                padding: 30,
                textAlign: 'center',
              }}
            >
              Photo by{' '}
              <TextLink href="https://unsplash.com/photos/mlOPryU1p_U">
                Annie Spratt
              </TextLink>
              .
            </div>
          </div>
        );
      }}
    </Spring>
  )}
</Demo>

## Perspective

By default, transforms still look very "2d". The rotations above don't look quite right, since objects closer to the viewer should look larger.

The solution to this is to apply a "perspective" property to the parent container. The value is given in px, and represents the distance that the viewer is from the item being transformed. The smaller the number, the more intense the transform effect.

<Demo
  id="perspective"
  initialValues={{
    perspective: 500,
  }}
  controls={(values, updateValue) => (
    <>
      <SliderControl
        id="perspective"
        label="Perspective"
        min={50}
        max={1250}
        value={values.perspective}
        updateValue={updateValue}
      />
    </>
  )}
>
  {({ perspective }) => (
    <Spring
      to={{ perspective }}
      config={{
        tension: 60,
        friction: 13,
      }}
    >
      {interpolated => (
        <div style={{ perspective: interpolated.perspective + 'px' }}>
          <div
            style={{
              paddingBottom: 30,
            }}
          >
            <InlineCode
              style={{
                position: 'relative',
                zIndex: 2,
                width: 400,
                fontSize: 24,
              }}
            >
              perspective: {Math.round(interpolated.perspective)}px
            </InlineCode>
          </div>
          <AutoRotate>
            <img width={400} height={321} src={pigletSrc} />
          </AutoRotate>
        </div>
      )}
    </Spring>
  )}
</Demo>

## Transform Origin

By default, rotations assume that you want to spin the items around their center point. The `transform-origin` property allows us to change the pivot point for rotation (and for all other transforms as well!)

Try changing it from the default "center" value to "top" or "bottom".

<Demo
  id="transform-origin"
  initialValues={{
    originX: 'center',
    originY: 'center',
  }}
  controls={(values, updateValue) => (
    <MultipleChoiceControl
      id="originY"
      label="Y"
      value={values.originY}
      updateValue={updateValue}
    >
      <Choice id="top">Top</Choice>
      <Choice id="center">Center</Choice>
      <Choice id="bottom">Bottom</Choice>
    </MultipleChoiceControl>
  )}
>
  {({ originY }) => (
    <div style={{ perspective: '1200px' }}>
      <div
        style={{
          paddingBottom: 30,
        }}
      >
        <InlineCode
          style={{
            position: 'relative',
            zIndex: 2,
            width: 475,
            fontSize: 24,
          }}
        >
          transform-origin: {originY} center;
        </InlineCode>
      </div>
      <AutoRotate style={{ transformOrigin: `${originY} center` }}>
        <img width={475} height={321} src={pigletSrc} />
      </AutoRotate>
    </div>
)}

</Demo>

## Adding a back

We mostly have all the pieces we need to produce this effect. One nice touch we can add is a backside, so that we can clearly tell the front and back apart when the item rotates fully. Notice how the back of this rotating card is a not-quite-opaque white:

<Demo id="transform-origin">
  {() => (
    <div style={{ perspective: '1200px' }}>
      <AutoRotate>
        <div style={{ position: 'relative' }}>
          <img width={475} height={321} src={pigletSrc} />
        </div>
        <div
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(255, 255, 255, 0.8)',
            transform: 'rotateX(180deg) translateZ(0.01px)',
            backfaceVisibility: 'hidden',
          }}
        />
      </AutoRotate>
    </div>
  )}
</Demo>

# Putting it all together

We're getting pretty close to all the pieces we need!

If we _split an image into two nodes_, we can _fold the bottom half_, and orient the fold along the _top edge of the bottom node_.
