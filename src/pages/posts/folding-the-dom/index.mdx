---
title: Folding the DOM
slug: folding-the-dom
published: false
publishedOn: 2018-10-05
abstract: A deep dive into DOM folding techniques, to be used in animations and interactions.
---

import { Spring } from 'react-spring';
import { State } from 'react-powerplug';
import styled, { keyframes } from 'styled-components';

import cssEngineSrc from '@assets/videos/css-engine.mp4';
import foldDemoImageSrc from '@assets/images/francois-hoang-china.jpg';
import foldDemoImageSmallSrc from '@assets/images/francois-hoang-china-small.jpg';
import pigletSrc from '@assets/images/annie-spratt-piglet.jpg';
import foldIssueSrc from '@assets/images/fold-issue.gif';

import Demo from '@components/Demo';
import MultipleChoiceControl, {
  Choice,
} from '@components/MultipleChoiceControl';
import SliderControl from '@components/SliderControl';
import TextLink from '@components/TextLink';
import SingleAxisDemo from '@components/SingleAxisDemo';
import VideoGif from '@components/VideoGif';
import InlineCode from '@components/InlineCode';
import Image from '@components/Image';
import AutoRotate from '@components/AutoRotate';
import { SingleFoldByRatio } from '@components/FoldDemos';
import LiveEditableCode from '@components/LiveEditableCode';

import mvpExampleCode from './code/mvp.example';
import backfaceInitialCode from './code/backface-initial.example';
import backfaceHiddenCode from './code/backface-hidden.example';

In my day-to-day life as a web developer, I generally treat CSS as a collection of 2D layers. Other than reordering them using z-index, I don't often _move_ things in 3D space.

And yet, for _years_ now, browsers have bundled in a surprisingly capable 3D CSS engine! Someone even built an experimental first-person shooter prototype using it ðŸ˜®

<VideoGif
  src={cssEngineSrc}
  caption={
    <>
      Believe it or not, this is just a collection of textured divs!{' '}
      <TextLink href="https://keithclark.co.uk/labs/css-fps/">
        View Live
      </TextLink>
    </>
  }
/>

Today I'd like to leverage that 3D engine to perform a neat trick: folding up an image.

Here's what we'll be building. Drag the slider downwards to reveal a [beautiful neon photo](https://unsplash.com/photos/2x6VHSRVqSA) by Francois Hoang:

<SingleAxisDemo showNote={true} defaultValue={100} id="fold-intro">
  {percentage => (
    <Spring
      to={{ percentage }}
      config={{
        tension: 60,
        friction: 13,
      }}
    >
      {interpolated => (
        <SingleFoldByRatio
          // The height of our node should be a fraction of the window height,
          // but no larger than 500px
          height={500}
          // Our width is just 2/3rds of our height.
          // Regrettably, because MDX doesn't support variables, I have to
          // duplicate all that stuff:
          width={375}
          percentage={interpolated.percentage}
        >
          <img src={foldDemoImageSrc} style={{ height: 500 }} />
        </SingleFoldByRatio>
      )}
    </Spring>
  )}
</SingleAxisDemo>

This effect could be useful in a number of scenarios:

- As a preloader for images. They unfold once they're ready, and the folded copy could use a much-lower-res base64-encoded version!
- As an on-mount animation when clicking to view an image, to add whimsical charm to an otherwise common feature.
- For JS game development

This tutorial is React-specific, but the concepts can easily be ported to vanilla JS/CSS, as well as other front-end frameworks.

**This is Part I of a two-part series.** In the next part, we'll look at how to generalize this effect to work on _any DOM node_, not just images.

## The Trick

Unfortunately, the DOM has no primitive for this; you can't actually fold a DOM node in two.

Instead, we need to be sneaky; we'll use _two_ images, and set them up so that it appears like a single image.

Each image is set to take up 50% of the real height, and then the bottom image has its `background-position` shifted up

<Demo
  id="transform-rotate"
  initialValues={{
    offset: 0,
  }}
  controls={(values, updateValue) => (
    <>
      <SliderControl
        id="offset"
        label="Offset"
        min={0}
        max={100}
        value={values.offset}
        updateValue={updateValue}
      />
    </>
  )}
>
  {({ offset }) => (
    <Spring
      to={{ offset }}
      config={{
        tension: 60,
        friction: 13,
      }}
    >
      {interpolated => {
        return (
          <div
            style={{
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
            }}
          >
            <div
              style={{
                width: 333,
                height: 250,
                backgroundSize: '333px 500px',
                backgroundImage: `url(${foldDemoImageSrc})`,
                borderRadius: offset < 100 ? '0 0 0 0' : '10px 10px 0 0',
              }}
            />
            <div
              style={{
                width: 333,
                height: 250,
                backgroundSize: '333px 500px',
                backgroundImage: `url(${foldDemoImageSrc})`,
                backgroundPosition: `0 ${interpolated.offset}%`,
                borderRadius: offset < 100 ? '0 0 0 0' : '0 0 10px 10px',
                transform: `translateY(${offset < 100 ? 5 : 0}px)`,
                transition: 'transform 250ms',
              }}
            />
            <InlineCode
              style={{
                position: 'relative',
                zIndex: 2,
                fontSize: 24,
                marginTop: 30,
              }}
            >
              background-position: '0 {Math.round(interpolated.offset)}%'
            </InlineCode>
          </div>
        );
      }}
    </Spring>
  )}
</Demo>

Pretty convincing, right? By juxtaposing the same image twice, and tweaking the offset of the background image, we're able to give the impression of a single
image.

To fold the bottom image up, we'll need to make use of a few CSS properties.

## Transform

Transform is our gateway to all sorts of effects. With transform, we can move stuff around, scale it larger and smaller, skew it, or rotate it.

In our case, we want to use a rotation, along the X axis:

<Demo
  id="transform-rotate"
  initialValues={{
    axis: 'X',
    degrees: 0,
  }}
  controls={(values, updateValue) => (
    <>
      <MultipleChoiceControl
        id="axis"
        label="Axis"
        value={values.axis}
        updateValue={updateValue}
      >
        <Choice id="X">X Axis</Choice>
        <Choice id="Y">Y Axis</Choice>
        <Choice id="Z">Z Axis</Choice>
      </MultipleChoiceControl>
      <SliderControl
        id="degrees"
        label="Degrees"
        min={0}
        max={360}
        value={values.degrees}
        updateValue={updateValue}
      />
    </>
  )}
>
  {({ axis, degrees }) => (
    <Spring
      to={{ degrees }}
      config={{
        tension: 60,
        friction: 13,
      }}
    >
      {interpolated => {
        const transform = `rotate${axis}(${interpolated.degrees}deg)`;
        //
        return (
          <div>
            <div
              style={{
                paddingBottom: 30,
              }}
            >
              <InlineCode
                style={{
                  position: 'relative',
                  zIndex: 2,
                  width: 400,
                  fontSize: 24,
                }}
              >
                transform: rotate{axis}({Math.round(interpolated.degrees)}deg)
              </InlineCode>
            </div>
            <img
              width={400}
              height={321}
              src={pigletSrc}
              style={{ transform }}
            />
            <div
              style={{
                position: 'relative',
                zIndex: 2,
                padding: 30,
                textAlign: 'center',
              }}
            >
              Photo by{' '}
              <TextLink href="https://unsplash.com/photos/mlOPryU1p_U">
                Annie Spratt
              </TextLink>
              .
            </div>
          </div>
        );
      }}
    </Spring>
  )}
</Demo>

## Perspective

By default, transforms still look very "2d". The rotations above don't look quite right, since objects closer to the viewer should look larger.

The solution to this is to apply a "perspective" property to the parent container. The value is given in px, and represents the distance that the viewer is from the item being transformed. The smaller the number, the more intense the transform effect.

<Demo
  id="perspective"
  initialValues={{
    perspective: 500,
  }}
  controls={(values, updateValue) => (
    <>
      <SliderControl
        id="perspective"
        label="Perspective"
        min={50}
        max={1250}
        value={values.perspective}
        updateValue={updateValue}
      />
    </>
  )}
>
  {({ perspective }) => (
    <Spring
      to={{ perspective }}
      config={{
        tension: 60,
        friction: 13,
      }}
    >
      {interpolated => (
        <div style={{ perspective: interpolated.perspective + 'px' }}>
          <div
            style={{
              paddingBottom: 30,
            }}
          >
            <InlineCode
              style={{
                position: 'relative',
                zIndex: 2,
                width: 400,
                fontSize: 24,
              }}
            >
              perspective: {Math.round(interpolated.perspective)}px
            </InlineCode>
          </div>
          <AutoRotate>
            <img width={400} height={321} src={pigletSrc} />
          </AutoRotate>
        </div>
      )}
    </Spring>
  )}
</Demo>

## Transform Origin

By default, rotations assume that you want to spin the items around their center point. The `transform-origin` property allows us to change the pivot point for rotation (and for all other transforms as well!)

Try changing it from the default "center" value to "top" or "bottom".

<Demo
  id="transform-origin"
  initialValues={{
    originX: 'center',
    originY: 'center',
  }}
  controls={(values, updateValue) => (
    <MultipleChoiceControl
      id="originY"
      label="Y"
      value={values.originY}
      updateValue={updateValue}
    >
      <Choice id="top">Top</Choice>
      <Choice id="center">Center</Choice>
      <Choice id="bottom">Bottom</Choice>
    </MultipleChoiceControl>
  )}
>
  {({ originY }) => (
    <div style={{ perspective: '1200px' }}>
      <div
        style={{
          paddingBottom: 30,
        }}
      >
        <InlineCode
          style={{
            position: 'relative',
            zIndex: 2,
            width: 475,
            fontSize: 24,
          }}
        >
          transform-origin: {originY} center;
        </InlineCode>
      </div>
      <AutoRotate style={{ transformOrigin: `${originY} center` }}>
        <img width={475} height={321} src={pigletSrc} />
      </AutoRotate>
    </div>
)}

</Demo>

# Our MVP

With all those pieces, we can achieve a "minimum viable product" for this effect. Here's what we get when we combine them:

<LiveEditableCode
  id="mvp-example"
  gistId="01114efda3cb02e4ffa3b49431c14982"
  code={mvpExampleCode}
  split={[70, 30]}
  maxHeight={585}
  scope={{ src: foldDemoImageSmallSrc }}
/>

With a little bit of CSS and a sprinkle of React state, we have the fundamental effect we're after!

You may have noticed, though, that it's missing some of the bells and whistles of the original demo. Let's flesh some of these out.

## Adding a backface

In our original demo, the "back" of the card has a slightly-transparent white background. The idea is to make it seem like a slightly-seethrough piece of paper.

Let's tackle this problem in isolation at first, and then we can add it in to our full demo.

First, we need a new `div`, with a nearly-opaque white background. We'll position this in the same place as our card:

<LiveEditableCode
  id="backface-initial"
  gistId="01114efda3cb02e4ffa3b49431c14982"
  code={backfaceInitialCode}
  split={[70, 30]}
  maxHeight={585}
  scope={{ src: foldDemoImageSmallSrc, styled, keyframes }}
/>

How do we ensure that this is only shown for the backside of the card? If you're like me, you're probably thinking of a JS solution, triggering `opacity` on a `setInterval` to show/hide it as the card rotates. Fortunately, though, CSS has an elegant solution for us, built right into the language!

We need to learn about a couple more properties:

### Backface Visibility

CSS lets us specify that the backside of an element shouldn't be visible, so that when its rotation eclipses 180 degrees, it shouldn't render anything.

Let's use this to hide our backface when it's facing away from the viewer:

<LiveEditableCode
  id="backface-initial"
  gistId="01114efda3cb02e4ffa3b49431c14982"
  code={backfaceHiddenCode}
  split={[70, 30]}
  maxHeight={585}
  scope={{ src: foldDemoImageSmallSrc, styled, keyframes }}
/>

### Transform Style

We need to add a new rule to the parent element: <InlineCode>transform-style: preserve-3d</InlineCode>.

This property allows elements to be positioned in 3D space. As we'll see, this is important because we'll have two DOM nodes occupying the same space: the front half of the card, and the back half. In a traditional web context, we'd use z-index to sort this out, but when working with transforms, we're delegating that to the 3D engine.

## Bug-fixing

If you're a Chrome user, you may have noticed an unsightly gap happening in the crook of the fold:

<Image src={foldIssueSrc} style={{ width: 420 }} />

I have no idea what the deal is with this. At first I thought it was a pixel-rounding issue, but it seems to happen with even numbers, where there should be no rounding. It only happens in Chrome, sometimes. I think it might be that, when using 3D transforms, pixel-perfection isn't guaranteed.

In true "every problem is a nail" fashion, we can use this trick again, adding a third copy of the image and putting it behind our two layers, to fill any gap that opens during the animation.

You can view the solution in the full source code. TODO

<Demo id="transform-origin">
  {() => (
    <div style={{ perspective: '1200px' }}>
      <AutoRotate>
        <div style={{ position: 'relative' }}>
          <img width={475} height={321} src={pigletSrc} />
        </div>
        <div
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(255, 255, 255, 0.8)',
            transform: 'rotateX(180deg) translateZ(0.01px)',
            backfaceVisibility: 'hidden',
          }}
        />
      </AutoRotate>
    </div>
  )}
</Demo>

# Putting it all together

We're getting pretty close to all the pieces we need!

If we _split an image into two nodes_, we can _fold the bottom half_, and orient the fold along the _top edge of the bottom node_.
