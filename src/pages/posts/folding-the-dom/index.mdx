---
title: Folding the DOM
slug: folding-the-dom
published: false
publishedOn: 2018-10-05
abstract: A deep dive into DOM folding techniques, to be used in animations and interactions.
---

import { Spring } from 'react-spring';
import { State } from 'react-powerplug';

import cssEngineSrc from '@assets/videos/css-engine.mp4';
import autumnSrc from '@assets/images/sandis-helvigs-autumn.jpg';
import pigletSrc from '@assets/images/annie-spratt-piglet.jpg';

import Demo from '@components/Demo';
import MultipleChoiceControl, {
  Choice,
} from '@components/MultipleChoiceControl';
import SliderControl from '@components/SliderControl';
import TextLink from '@components/TextLink';
import SingleAxisDemo from '@components/SingleAxisDemo';
import VideoGif from '@components/VideoGif';
import InlineCode from '@components/InlineCode';
import { SingleFoldByRatio } from '@components/FoldDemos';

In my day-to-day life as a web developer, I generally treat CSS as a collection of 2D layers. Other than reordering them using z-index, I don't often _move_ things in 3D space.

And yet, for _years_ now, browsers have bundled in a surprisingly capable 3D CSS engine! Someone even built an experimental first-person shooter prototype using it ðŸ˜®

<VideoGif
  src={cssEngineSrc}
  caption={
    <>
      Believe it or not, this is just a collection of textured divs!{' '}
      <TextLink href="https://keithclark.co.uk/labs/css-fps/">
        View Live
      </TextLink>
    </>
  }
/>

Today I'd like to leverage that 3D engine to perform a neat trick: folding up a DOM node. This effect is a great way to add some whimsical charm to your web products.

Take a look at what I mean, by unfolding this [beautiful autumn photo](https://unsplash.com/photos/vrY49w_-Bmc) by Sandis Helvigs:

<SingleAxisDemo showNote={true} defaultValue={100} id="fold-intro">
  {percentage => (
    <Spring
      to={{ percentage }}
      config={{
        tension: 60,
        friction: 13,
      }}
    >
      {interpolated => (
        <SingleFoldByRatio
          // The height of our node should be a fraction of the window height,
          // but no larger than 500px
          height={
            typeof window !== 'undefined' &&
            Math.min(Math.round(window.innerHeight * 0.6), 500)
          }
          // Our width is just 2/3rds of our height.
          // Regrettably, because MDX doesn't support variables, I have to
          // duplicate all that stuff:
          width={
            typeof window !== 'undefined' &&
            Math.min(Math.round(window.innerHeight * 0.6 * 0.666), 333)
          }
          percentage={interpolated.percentage}
        >
          <img src={autumnSrc} style={{ width: '100%' }} />
        </SingleFoldByRatio>
      )}
    </Spring>
  )}
</SingleAxisDemo>

## The Trick

Unfortunately, the DOM has no primitive for this; you can't actually fold a DOM node in two.

Instead, we need to be sneaky; we'll use _two_ images, and set them up so that it appears like a single image.

If we only needed to support images, we could use `background-position` to "crop" the second image, exactly as we need:

<Demo
  id="transform-rotate"
  initialValues={{
    offset: 0,
  }}
  controls={(values, updateValue) => (
    <>
      <SliderControl
        id="offset"
        label="Offset"
        min={0}
        max={250}
        value={values.offset}
        updateValue={updateValue}
      />
    </>
  )}
>
  {({ offset }) => (
    <Spring
      to={{ offset }}
      config={{
        tension: 60,
        friction: 13,
      }}
    >
      {interpolated => {
        return (
          <div
            style={{
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
            }}
          >
            <div
              style={{
                width: 333,
                height: 250,
                backgroundSize: '333px 500px',
                backgroundImage: `url(${autumnSrc})`,
                borderRadius: offset < 250 ? '0 0 0 0' : '10px 10px 0 0',
              }}
            />
            <div
              style={{
                width: 333,
                height: 250,
                backgroundSize: '333px 500px',
                backgroundImage: `url(${autumnSrc})`,
                backgroundPosition: `0px -${interpolated.offset}px`,
                borderRadius: offset < 250 ? '0 0 0 0' : '0 0 10px 10px',
                transform: `translateY(${offset < 250 ? 5 : 0}px)`,
                transition: 'transform 250ms',
              }}
            />
            <InlineCode
              style={{
                position: 'relative',
                zIndex: 2,
                fontSize: 24,
                marginTop: 30,
              }}
            >
              background-position: '0px -{Math.round(interpolated.offset)}px'
            </InlineCode>
          </div>
        );
      }}
    </Spring>
  )}
</Demo>

This effect uses CSS transform: rotateX to rotate the bottom half upwards. There are a few CSS properties that we'll be leveraging:

## Transform

Transform is our gateway to all sorts of effects. With transform, we can move stuff around, scale it larger and smaller, skew it, or rotate it.

In our

<Demo
  id="transform-rotate"
  initialValues={{
    axis: 'X',
    degrees: 0,
  }}
  controls={(values, updateValue) => (
    <>
      <MultipleChoiceControl
        id="axis"
        label="Axis"
        value={values.axis}
        updateValue={updateValue}
      >
        <Choice id="X">X Axis</Choice>
        <Choice id="Y">Y Axis</Choice>
        <Choice id="Z">Z Axis</Choice>
      </MultipleChoiceControl>
      <SliderControl
        id="degrees"
        label="Degrees"
        min={0}
        max={360}
        value={values.degrees}
        updateValue={updateValue}
      />
    </>
  )}
>
  {({ axis, degrees }) => (
    <Spring
      to={{ degrees }}
      config={{
        tension: 60,
        friction: 13,
      }}
    >
      {interpolated => {
        const transform = `rotate${axis}(${interpolated.degrees}deg)`;
        //
        return (
          <div style={{ perspective: 500 }}>
            <div
              style={{
                paddingBottom: 30,
              }}
            >
              <InlineCode
                style={{
                  position: 'relative',
                  zIndex: 2,
                  width: 400,
                  fontSize: 24,
                }}
              >
                transform: rotate{axis}({Math.round(interpolated.degrees)}deg)
              </InlineCode>
            </div>
            <img
              width={400}
              height={321}
              src={pigletSrc}
              style={{ transform }}
            />
            <div
              style={{
                position: 'relative',
                zIndex: 2,
                padding: 30,
                textAlign: 'center',
              }}
            >
              Photo by{' '}
              <TextLink href="https://unsplash.com/photos/mlOPryU1p_U">
                Annie Spratt
              </TextLink>
              .
            </div>
          </div>
        );
      }}
    </Spring>
  )}
</Demo>

## Perspective

Perspective is a CSS property that controls the distance between the "camera" and the element. Elements much closer to the camera will have a much more dramatic effect when moving in 3D.
